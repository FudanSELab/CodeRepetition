{"ID": 14, "source": "HumanEval:HumanEval/14", "prompt": "from typing import List\n\n\n\"\"\" Return list of all prefixes from shortest to longest of the input string\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\"\"\"\ndef all_prefixes(string: str) -> List[str]:", "predict": "<｜begin▁of▁sentence｜>from typing import List\n\n\n\"\"\" Return list of all prefixes from shortest to longest of the input string\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\"\"\"\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:i] for i in range(1, len(string) + 1)]\n\n\n\"\"\" Return list of all suffixes from shortest to longest of the input string\n>>> all_suffixes('abc')\n['c', 'bc', 'abc']\n\"\"\"\ndef all_suffixes(string: str) -> List[str]:\n    return [string[i:] for i in range(len(string))]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string\n>>> all_substrings('abc')\n['a', 'ab', 'abc', 'b', 'bc', 'c']\n\"\"\"\ndef all_substrings(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string,\n    but only include substrings that are palindromes\n>>> palindrome_substrings('abc')\n['a', 'b', 'c']\n\"\"\"\ndef palindrome_substrings(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1) if string[i:j] == string[i:j][::-1]]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string,\n    but only include substrings that are palindromes and have length greater than 1\n>>> palindrome_substrings('abc')\n[]\n\"\"\"\ndef palindrome_substrings_length_gt_1(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 2, len(string) + 1) if string[i:j] == string[i:j][::-1]]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string,\n    but only include substrings that are palindromes and have length greater than 1\n>>> palindrome_substrings_length_", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "['c', 'bc', 'abc']\n\"\"\"\ndef all_suffixes(string: str) -> List[str]:\n    return [string[i:] for i in range(len(string))]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string\n>>> all_substrings('abc')\n['a', 'ab', 'abc', 'b', 'bc', 'c']\n\"\"\"\ndef all_substrings(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string,\n    but only include substrings that are palindromes\n>>> palindrome_substrings('abc')\n['a', 'b', 'c']\n\"\"\"\ndef palindrome_substrings(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1) if string[i:j] == string[i:j][::-1]]\n\n\n\"\"\" Return list of all substrings from shortest to longest of the input string,\n    but only include substrings that are palindromes and have length greater than 1\n>>> palindrome_substrings('abc')\n[]\n\"\"\"\ndef palindrome_substrings_length_gt_1(string: str) -> List[str]:\n    return [string[i:j] for i in range(len(string)) for j in range(i + 2, len(string) + 1) if string[i:j] == string[i:j][::-1]]\n\n"}
{"ID": 22, "source": "HumanEval:HumanEval/22", "prompt": "from typing import List, Any\n\n\n\"\"\" Filter given list of any python values only for integers\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\"\"\"\ndef filter_integers(values: List[Any]) -> List[int]:", "predict": "<｜begin▁of▁sentence｜>from typing import List, Any\n\n\n\"\"\" Filter given list of any python values only for integers\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\"\"\"\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]\n\n\n\"\"\" Filter given list of any python values only for strings\n>>> filter_strings(['a', 3.14, 5])\n['a']\n>>> filter_strings([1, 2, 3, 'abc', {}, []])\n['abc']\n\"\"\"\ndef filter_strings(values: List[Any]) -> List[str]:\n    return [value for value in values if isinstance(value, str)]\n\n\n\"\"\" Filter given list of any python values only for floats\n>>> filter_floats(['a', 3.14, 5])\n[3.14]\n>>> filter_floats([1, 2, 3, 'abc', {}, []])\n[]\n\"\"\"\ndef filter_floats(values: List[Any]) -> List[float]:\n    return [value for value in values if isinstance(value, float)]\n\n\n\"\"\" Filter given list of any python values only for dictionaries\n>>> filter_dictionaries(['a', 3.14, 5])\n[]\n>>> filter_dictionaries([1, 2, 3, 'abc', {}, []])\n[{}]\n\"\"\"\ndef filter_dictionaries(values: List[Any]) -> List[dict]:\n    return [value for value in values if isinstance(value, dict)]\n\n\n\"\"\" Filter given list of any python values only for lists\n>>> filter_lists(['a', 3.14, 5])\n[]\n>>> filter_lists([1, 2, 3, 'abc', {}, []])\n[[], []]\n\"\"\"\ndef filter_lists(values: List[Any]) -> List[list]:\n    return [value for value in values if isinstance(value, list)]\n\n\n\"\"\" Filter given list of any python values only for tuples\n>>> filter_tuples(['a', 3.14, 5])\n[]\n>>> filter_tuples([1, 2, 3, 'abc', {}, []])\n[]\n\"\"\"\ndef filter_tuples(values: List[Any]) -> List[tuple]:\n    return [value for value in values if isinstance(value, tuple)]\n\n\n\"\"\"", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "    return [value for value in values if isinstance(value, str)]\n\n\n\"\"\" Filter given list of any python values only for floats\n>>> filter_floats(['a', 3.14, 5])\n[3.14]\n>>> filter_floats([1, 2, 3, 'abc', {}, []])\n[]\n\"\"\"\ndef filter_floats(values: List[Any]) -> List[float]:\n    return [value for value in values if isinstance(value, float)]\n\n\n\"\"\" Filter given list of any python values only for dictionaries\n>>> filter_dictionaries(['a', 3.14, 5])\n[]\n>>> filter_dictionaries([1, 2, 3, 'abc', {}, []])\n[{}]\n\"\"\"\ndef filter_dictionaries(values: List[Any]) -> List[dict]:\n    return [value for value in values if isinstance(value, dict)]\n\n\n\"\"\" Filter given list of any python values only for lists\n>>> filter_lists(['a', 3.14, 5])\n[]\n>>> filter_lists([1, 2, 3, 'abc', {}, []])\n[[], []]\n\"\"\"\ndef filter_lists(values: List[Any]) -> List[list]:\n    return [value for value in values if isinstance(value, list)]\n\n\n\"\"\" Filter given list of any python values only for tuples\n>>> filter_tuples(['a', 3.14, 5])\n[]\n>>> filter_tuples([1, 2, 3, 'abc', {}, []])\n[]\n\"\"\"\ndef filter_tuples(values: List[Any]) -> List[tuple]:"}
{"ID": 23, "source": "HumanEval:HumanEval/23", "prompt": "\n\n\"\"\" Return length of given string\n>>> strlen('')\n0\n>>> strlen('abc')\n3\n\"\"\"\ndef strlen(string: str) -> int:", "predict": "<｜begin▁of▁sentence｜>\n\n\"\"\" Return length of given string\n>>> strlen('')\n0\n>>> strlen('abc')\n3\n\"\"\"\ndef strlen(string: str) -> int:\n    return len(string)\n\n\n\"\"\" Return reversed string\n>>> reverse('')\n''\n>>> reverse('abc')\n'cba'\n\"\"\"\ndef reverse(string: str) -> str:\n    return string[::-1]\n\n\n\"\"\" Return True if string is palindrome, False otherwise\n>>> is_palindrome('')\nTrue\n>>> is_palindrome('abc')\nFalse\n>>> is_palindrome('abcba')\nTrue\n\"\"\"\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\n\n\"\"\" Return True if string is empty, False otherwise\n>>> is_empty('')\nTrue\n>>> is_empty('abc')\nFalse\n\"\"\"\ndef is_empty(string: str) -> bool:\n    return len(string) == 0\n\n\n\"\"\" Return True if string is uppercase, False otherwise\n>>> is_uppercase('')\nTrue\n>>> is_uppercase('ABC')\nTrue\n>>> is_uppercase('Abc')\nFalse\n\"\"\"\ndef is_uppercase(string: str) -> bool:\n    return string.isupper()\n\n\n\"\"\" Return True if string is lowercase, False otherwise\n>>> is_lowercase('')\nTrue\n>>> is_lowercase('abc')\nTrue\n>>> is_lowercase('Abc')\nFalse\n\"\"\"\ndef is_lowercase(string: str) -> bool:\n    return string.islower()\n\n\n\"\"\" Return True if string is titlecase, False otherwise\n>>> is_titlecase('')\nTrue\n>>> is_titlecase('Abc')\nTrue\n>>> is_titlecase('abc')\nFalse\n\"\"\"\ndef is_titlecase(string: str) -> bool:\n    return string.istitle()\n\n\n\"\"\" Return True if string is alpha, False otherwise\n>>> is_alpha('')\nTrue\n>>> is_alpha('abc')\nTrue\n>>> is_alpha('abc123')\nFalse\n\"\"\"\ndef is_alpha(string: str) -> bool:\n    return string.isalpha()\n\n\n\"\"\" Return True if string is numeric, False otherwise\n>>> is_numeric('')\nTrue\n>>> is_numer", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": ">>> reverse('')\n''\n>>> reverse('abc')\n'cba'\n\"\"\"\ndef reverse(string: str) -> str:\n    return string[::-1]\n\n\n\"\"\" Return True if string is palindrome, False otherwise\n>>> is_palindrome('')\nTrue\n>>> is_palindrome('abc')\nFalse\n>>> is_palindrome('abcba')\nTrue\n\"\"\"\ndef is_palindrome(string: str) -> bool:\n    return string == string[::-1]\n\n\n\"\"\" Return True if string is empty, False otherwise\n>>> is_empty('')\nTrue\n>>> is_empty('abc')\nFalse\n\"\"\"\ndef is_empty(string: str) -> bool:\n    return len(string) == 0\n\n\n\"\"\" Return True if string is uppercase, False otherwise\n>>> is_uppercase('')\nTrue\n>>> is_uppercase('ABC')\nTrue\n>>> is_uppercase('Abc')\nFalse\n\"\"\"\ndef is_uppercase(string: str) -> bool:\n    return string.isupper()\n\n\n\"\"\" Return True if string is lowercase, False otherwise\n>>> is_lowercase('')\nTrue\n>>> is_lowercase('abc')\nTrue\n>>> is_lowercase('Abc')\nFalse\n\"\"\"\ndef is_lowercase(string: str) -> bool:\n    return string.islower()\n\n"}
{"ID": 30, "source": "HumanEval:HumanEval/30", "prompt": "\n\n\"\"\"Return only positive numbers in the list.\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n\"\"\"\ndef get_positive(l: list):", "predict": "<｜begin▁of▁sentence｜>\n\n\"\"\"Return only positive numbers in the list.\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n\"\"\"\ndef get_positive(l: list):\n    return [i for i in l if i > 0]\n\n\n\"\"\"Return only even numbers in the list.\n>>> get_even([1, 2, 3, 4, 5])\n[2, 4]\n>>> get_even([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_even(l: list):\n    return [i for i in l if i % 2 == 0]\n\n\n\"\"\"Return only odd numbers in the list.\n>>> get_odd([1, 2, 3, 4, 5])\n[1, 3, 5]\n>>> get_odd([10, 20, 30, 40, 50])\n[]\n\"\"\"\ndef get_odd(l: list):\n    return [i for i in l if i % 2 != 0]\n\n\n\"\"\"Return only numbers that are multiples of 3 in the list.\n>>> get_multiples_of_3([1, 2, 3, 4, 5])\n[3]\n>>> get_multiples_of_3([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_multiples_of_3(l: list):\n    return [i for i in l if i % 3 == 0]\n\n\n\"\"\"Return only numbers that are multiples of 5 in the list.\n>>> get_multiples_of_5([1, 2, 3, 4, 5])\n[5]\n>>> get_multiples_of_5([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_multiples_of_5(l: list):\n    return [i for i in l if i % 5 == 0]\n\n\n\"\"\"Return only numbers that are multiples of 7 in the list.\n>>> get", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    return [i for i in l if i > 0]\n\n\n\"\"\"Return only even numbers in the list.\n>>> get_even([1, 2, 3, 4, 5])\n[2, 4]\n>>> get_even([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_even(l: list):\n    return [i for i in l if i % 2 == 0]\n\n\n\"\"\"Return only odd numbers in the list.\n>>> get_odd([1, 2, 3, 4, 5])\n[1, 3, 5]\n>>> get_odd([10, 20, 30, 40, 50])\n[]\n\"\"\"\ndef get_odd(l: list):\n    return [i for i in l if i % 2 != 0]\n\n\n\"\"\"Return only numbers that are multiples of 3 in the list.\n>>> get_multiples_of_3([1, 2, 3, 4, 5])\n[3]\n>>> get_multiples_of_3([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_multiples_of_3(l: list):\n    return [i for i in l if i % 3 == 0]\n\n\n\"\"\"Return only numbers that are multiples of 5 in the list.\n>>> get_multiples_of_5([1, 2, 3, 4, 5])\n[5]\n>>> get_multiples_of_5([10, 20, 30, 40, 50])\n[10, 20, 30, 40, 50]\n\"\"\"\ndef get_multiples_of_5(l: list):\n    return [i for i in l if i % 5 == 0]\n\n\n\"\"\"Return only numbers that are multiples of 7 in the list."}
{"ID": 34, "source": "HumanEval:HumanEval/34", "prompt": "\n\n\"\"\"Return sorted unique elements in a list\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\"\"\"\ndef unique(l: list):", "predict": "<｜begin▁of▁sentence｜>\n\n\"\"\"Return sorted unique elements in a list\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\"\"\"\ndef unique(l: list):\n    return sorted(set(l))\n\n\n\"\"\"Return the number of unique elements in a list\n>>> unique_count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n6\n\"\"\"\ndef unique_count(l: list):\n    return len(set(l))\n\n\n\"\"\"Return the number of occurrences of each element in a list\n>>> count_occurrences([5, 3, 5, 2, 3, 3, 9, 0, 123])\n{5: 2, 3: 3, 2: 1, 9: 1, 0: 1, 123: 1}\n\"\"\"\ndef count_occurrences(l: list):\n    return {i: l.count(i) for i in l}\n\n\n\"\"\"Return the number of occurrences of each unique element in a list\n>>> count_unique_occurrences([5, 3, 5, 2, 3, 3, 9, 0, 123])\n{5: 2, 3: 3, 2: 1, 9: 1, 0: 1, 123: 1}\n\"\"\"\ndef count_unique_occurrences(l: list):\n    return {i: l.count(i) for i in set(l)}\n\n\n\"\"\"Return the number of occurrences of each unique element in a list, sorted by the number of occurrences\n>>> count_unique_occurrences_sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[(5, 2), (3, 3), (2, 1), (9, 1), (0, 1), (123, 1)]\n\"\"\"\ndef count_unique_occurrences_sorted(l: list):\n    return sorted(count_unique_occurrences(l).items(), key=lambda x: x[1])\n\n\n\"\"\"Return the number of occurrences of each unique element in a list, sorted by", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": ">>> unique_count([5, 3, 5, 2, 3, 3, 9, 0, 123])\n6\n\"\"\"\ndef unique_count(l: list):\n    return len(set(l))\n\n\n\"\"\"Return the number of occurrences of each element in a list\n>>> count_occurrences([5, 3, 5, 2, 3, 3, 9, 0, 123])\n{5: 2, 3: 3, 2: 1, 9: 1, 0: 1, 123: 1}\n\"\"\"\ndef count_occurrences(l: list):\n    return {i: l.count(i) for i in l}\n\n\n\"\"\"Return the number of occurrences of each unique element in a list\n>>> count_unique_occurrences([5, 3, 5, 2, 3, 3, 9, 0, 123])\n{5: 2, 3: 3, 2: 1, 9: 1, 0: 1, 123: 1}\n\"\"\"\ndef count_unique_occurrences(l: list):\n    return {i: l.count(i) for i in set(l)}\n\n\n\"\"\"Return the number of occurrences of each unique element in a list, sorted by the number of occurrences"}
{"ID": 35, "source": "HumanEval:HumanEval/35", "prompt": "\n\n\"\"\"Return maximum element in the list.\n>>> max_element([1, 2, 3])\n3\n>>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n\"\"\"\ndef max_element(l: list):", "predict": "<｜begin▁of▁sentence｜>\n\n\"\"\"Return maximum element in the list.\n>>> max_element([1, 2, 3])\n3\n>>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n\"\"\"\ndef max_element(l: list):\n    return max(l)\n\n\n\"\"\"Return minimum element in the list.\n>>> min_element([1, 2, 3])\n1\n>>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n-10\n\"\"\"\ndef min_element(l: list):\n    return min(l)\n\n\n\"\"\"Return sum of all elements in the list.\n>>> sum_elements([1, 2, 3])\n6\n>>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n126\n\"\"\"\ndef sum_elements(l: list):\n    return sum(l)\n\n\n\"\"\"Return average of all elements in the list.\n>>> average_elements([1, 2, 3])\n2.0\n>>> average_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n21.6\n\"\"\"\ndef average_elements(l: list):\n    return sum(l) / len(l)\n\n\n\"\"\"Return median of all elements in the list.\n>>> median_elements([1, 2, 3])\n2\n>>> median_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n3\n\"\"\"\ndef median_elements(l: list):\n    n = len(l)\n    s = sorted(l)\n    return (sum(s[n//2-1:n//2+1])/2.0, s[n//2])[n % 2]\n\n\n\"\"\"Return mode of all elements in the list.\n>>> mode_elements([1, 2, 3])\n1\n>>> mode_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n1\n\"\"\"\ndef mode_elements(l: list", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    return max(l)\n\n\n\"\"\"Return minimum element in the list.\n>>> min_element([1, 2, 3])\n1\n>>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n-10\n\"\"\"\ndef min_element(l: list):\n    return min(l)\n\n\n\"\"\"Return sum of all elements in the list.\n>>> sum_elements([1, 2, 3])\n6\n>>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n126\n\"\"\"\ndef sum_elements(l: list):\n    return sum(l)\n\n\n\"\"\"Return average of all elements in the list.\n>>> average_elements([1, 2, 3])\n2.0\n>>> average_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n21.6\n\"\"\"\ndef average_elements(l: list):\n    return sum(l) / len(l)\n\n\n\"\"\"Return median of all elements in the list.\n>>> median_elements([1, 2, 3])"}
{"ID": 42, "source": "HumanEval:HumanEval/42", "prompt": "\n\n\"\"\"Return list with elements incremented by 1.\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n\"\"\"\ndef incr_list(l: list):", "predict": "<｜begin▁of▁sentence｜>\n\n\"\"\"Return list with elements incremented by 1.\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n\"\"\"\ndef incr_list(l: list):\n    return [i + 1 for i in l]\n\n\n\"\"\"Return list with elements decremented by 1.\n>>> decr_list([1, 2, 3])\n[0, 1, 2]\n>>> decr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[4, 2, 4, 1, 2, 2, 8, -1, 122]\n\"\"\"\ndef decr_list(l: list):\n    return [i - 1 for i in l]\n\n\n\"\"\"Return list with elements multiplied by 2.\n>>> double_list([1, 2, 3])\n[2, 4, 6]\n>>> double_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[10, 6, 10, 4, 6, 6, 18, 0, 246]\n\"\"\"\ndef double_list(l: list):\n    return [i * 2 for i in l]\n\n\n\"\"\"Return list with elements divided by 2.\n>>> half_list([1, 2, 3])\n[0.5, 1.0, 1.5]\n>>> half_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[2.5, 1.5, 2.5, 1.0, 1.5, 1.5, 4.5, 0.0, 61.5]\n\"\"\"\ndef half_list(l: list):\n    return [i / 2 for i in l]\n\n\n\"\"\"Return list with elements squared.\n>>> square_list([1, 2, 3])\n[1, 4, 9]\n>>> square_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[25, 9, 25, 4, 9, 9,", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    return [i + 1 for i in l]\n\n\n\"\"\"Return list with elements decremented by 1.\n>>> decr_list([1, 2, 3])\n[0, 1, 2]\n>>> decr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[4, 2, 4, 1, 2, 2, 8, -1, 122]\n\"\"\"\ndef decr_list(l: list):\n    return [i - 1 for i in l]\n\n\n\"\"\"Return list with elements multiplied by 2.\n>>> double_list([1, 2, 3])\n[2, 4, 6]\n>>> double_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[10, 6, 10, 4, 6, 6, 18, 0, 246]\n\"\"\"\ndef double_list(l: list):\n    return [i * 2 for i in l]\n\n\n\"\"\"Return list with elements divided by 2.\n>>> half_list([1, 2, 3])\n[0.5, 1.0, 1.5]"}
{"ID": 77, "source": "HumanEval:HumanEval/77", "prompt": "\n\ndef iscube(a):", "predict": "<｜begin▁of▁sentence｜>\n\ndef iscube(a):\n    x = round(a ** (1. / 3.))\n    return x * x * x == a\n\n\ndef is_cube(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_2(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_3(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_4(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_5(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_6(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_7(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_8(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_9(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_10(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_11(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_12(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_13(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_14(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_15(n):\n    return round(n **", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "    return x * x * x == a\n\n\ndef is_cube(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_2(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_3(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_4(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_5(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_6(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_7(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_8(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_9(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_10(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_11(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_12(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_13(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_14(n):\n    return round(n ** (1. / 3.)) ** 3 == n\n\n\ndef is_cube_15(n):"}
{"ID": 99, "source": "HumanEval:HumanEval/99", "prompt": "\n\ndef closest_integer(value):", "predict": "<｜begin▁of▁sentence｜>\n\ndef closest_integer(value):\n    return round(value)\n\n\ndef closest_integer_with_precision(value, precision):\n    return round(value, precision)\n\n\ndef closest_integer_with_precision_and_rounding(value, precision, rounding):\n    return round(value, precision, rounding)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode(value, precision, rounding, mode):\n    return round(value, precision, rounding, mode)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties(value, precision, rounding, mode, ties):\n    return round(value, precision, rounding, mode, ties)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity(value, precision, rounding, mode, ties, infinity):\n    return round(value, precision, rounding, mode, ties, infinity)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude(value, precision, rounding, mode, ties, infinity, magnitude):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude_and_direction(value, precision, rounding, mode, ties, infinity, magnitude, direction):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude, direction)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude_and_direction_and_digits(value, precision, rounding, mode, ties, infinity, magnitude, direction, digits):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude, direction, digits)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_m", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "    return round(value)\n\n\ndef closest_integer_with_precision(value, precision):\n    return round(value, precision)\n\n\ndef closest_integer_with_precision_and_rounding(value, precision, rounding):\n    return round(value, precision, rounding)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode(value, precision, rounding, mode):\n    return round(value, precision, rounding, mode)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties(value, precision, rounding, mode, ties):\n    return round(value, precision, rounding, mode, ties)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity(value, precision, rounding, mode, ties, infinity):\n    return round(value, precision, rounding, mode, ties, infinity)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude(value, precision, rounding, mode, ties, infinity, magnitude):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude_and_direction(value, precision, rounding, mode, ties, infinity, magnitude, direction):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude, direction)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_magnitude_and_direction_and_digits(value, precision, rounding, mode, ties, infinity, magnitude, direction, digits):\n    return round(value, precision, rounding, mode, ties, infinity, magnitude, direction, digits)\n\n\ndef closest_integer_with_precision_and_rounding_and_mode_and_ties_and_infinity_and_m"}
{"ID": 134, "source": "HumanEval:HumanEval/134", "prompt": "\n\ndef check_if_last_char_is_a_letter(txt):", "predict": "<｜begin▁of▁sentence｜>\n\ndef check_if_last_char_is_a_letter(txt):\n    if txt[-1].isalpha():\n        return True\n    else:\n        return False\n\n\ndef check_if_first_char_is_a_letter(txt):\n    if txt[0].isalpha():\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_empty(txt):\n    if txt == \"\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_number(txt):\n    if txt.isdigit():\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_float(txt):\n    try:\n        float(txt)\n        return True\n    except ValueError:\n        return False\n\n\ndef check_if_string_is_a_integer(txt):\n    try:\n        int(txt)\n        return True\n    except ValueError:\n        return False\n\n\ndef check_if_string_is_a_boolean(txt):\n    if txt.lower() == \"true\" or txt.lower() == \"false\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_list(txt):\n    if txt[0] == \"[\" and txt[-1] == \"]\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_dictionary(txt):\n    if txt[0] == \"{\" and txt[-1] == \"}\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_tuple(txt):\n    if txt[0] == \"(\" and txt[-1] == \")\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_set(txt):\n    if txt[0] == \"{\" and txt[-1] == \"}\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_date(txt):\n    try:\n        datetime.datetime.strptime(txt, '%Y-%m-%d')", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    if txt[-1].isalpha():\n        return True\n    else:\n        return False\n\n\ndef check_if_first_char_is_a_letter(txt):\n    if txt[0].isalpha():\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_empty(txt):\n    if txt == \"\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_number(txt):\n    if txt.isdigit():\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_float(txt):\n    try:\n        float(txt)\n        return True\n    except ValueError:\n        return False\n\n\ndef check_if_string_is_a_integer(txt):\n    try:\n        int(txt)\n        return True\n    except ValueError:\n        return False\n\n\ndef check_if_string_is_a_boolean(txt):\n    if txt.lower() == \"true\" or txt.lower() == \"false\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_list(txt):\n    if txt[0] == \"[\" and txt[-1] == \"]\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_dictionary(txt):\n    if txt[0] == \"{\" and txt[-1] == \"}\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_tuple(txt):\n    if txt[0] == \"(\" and txt[-1] == \")\":\n        return True\n    else:\n        return False\n\n\ndef check_if_string_is_a_set(txt):\n    if txt[0] == \"{\" and txt[-1] == \"}\":\n        return True\n    else:\n        return False"}
{"ID": 139, "source": "HumanEval:HumanEval/139", "prompt": "\n\"\"\"The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\"\"\"\ndef special_factorial(n):", "predict": "<｜begin▁of▁sentence｜>\n\"\"\"The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\"\"\"\ndef special_factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * special_factorial(n - 1)\n\ndef brazilian_factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n) * brazilian_factorial(n - 1)\n\n# Test cases\nprint(brazilian_factorial(4))  # Output: 288\nprint(brazilian_factorial(5))  # Output: 34560\nprint(brazilian_factorial(6))  # Output: 6451200\nprint(brazilian_factorial(7))  # Output: 159667200\nprint(brazilian_factorial(8))  # Output: 5189184000\nprint(brazilian_factorial(9))  # Output: 2183401056000\nprint(brazilian_factorial(10))  # Output: 1329256158426240000\nprint(brazilian_factorial(11))  # Output: 1089725714531225600000\nprint(brazilian_factorial(12))  # Output: 1181219417689544576000000\nprint(brazilian_factorial(13))  # Output: 1619002487249817948160000000\nprint(brazilian_factorial(14))  # Output: 27777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777", "is_repeat": true, "repeat_type": "character_repetition", "repeat_code": "print(brazilian_factorial(14))  # Output: 27777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777"}
{"ID": 141, "source": "HumanEval:HumanEval/141", "prompt": "\n\"\"\"Create a function which takes a string representing a file's name, and returns\n'Yes' if the the file's name is valid, and returns 'No' otherwise.\nA file's name is considered to be valid if and only if all the following conditions \nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from \nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\nExamples:\nfile_name_check(\"example.txt\") # => 'Yes'\nfile_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n\"\"\"\ndef file_name_check(file_name):", "predict": "<｜begin▁of▁sentence｜>\n\"\"\"Create a function which takes a string representing a file's name, and returns\n'Yes' if the the file's name is valid, and returns 'No' otherwise.\nA file's name is considered to be valid if and only if all the following conditions \nare met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from \nthe latin alphapet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\nExamples:\nfile_name_check(\"example.txt\") # => 'Yes'\nfile_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n\"\"\"\ndef file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    if file_name.count('0') + file_name.count('1') + file_name.count('2') + file_name.count('3') + file_name.count('4') + file_name.count('5') + file_name.count('6') + file_name.count('7') + file_name.count('8') + file_name.count('9') > 3:\n        return 'No'\n    if not file_name[0].isalpha():\n        return 'No'\n    if file_name.split('.')[0] == '':\n        return 'No'\n    if file_name.split('.')[1] not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'\n\nprint(file_name_check(\"example.txt\")) # => 'Yes'\nprint(file_name_check(\"1example.dll\")) # => 'No' (the name should start with a latin alphapet letter)\nprint(file_name_check(\"example.exe\")) # => 'Yes'\nprint(file_name_check(\"example.dll\")) # => 'Yes'\nprint(file_name_check(\"example.txt.exe\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe.dll.txt\"))", "is_repeat": true, "repeat_type": "statement_repetition", "repeat_code": "print(file_name_check(\"example.txt\")) # => 'Yes'\nprint(file_name_check(\"1example.dll\")) # => 'No' (the name should start with a latin alphapet letter)\nprint(file_name_check(\"example.exe\")) # => 'Yes'\nprint(file_name_check(\"example.dll\")) # => 'Yes'\nprint(file_name_check(\"example.txt.exe\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe.dll\")) # => 'No' (there should be exactly one dot)\nprint(file_name_check(\"example.txt.exe.dll.txt.exe.dll.txt\"))"}
{"ID": 148, "source": "HumanEval:HumanEval/148", "prompt": "\n\ndef bf(planet1, planet2):", "predict": "<｜begin▁of▁sentence｜>\n\ndef bf(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n\ndef bf_vec_vec_vec_vec_vec_vec(planet1, planet2):\n    return (planet1.x - planet2.x)**2 + (planet1.y - planet2.y)**2 + (planet1.z - planet2.z)**2\n"}
