{"ID": 9, "source": "HumanEval:HumanEval/9", "prompt": "from typing import List, Tuple\n\n\n\"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\"\"\"\ndef rolling_max(numbers: List[int]) -> List[int]:", "predict": "from typing import List, Tuple\n\n\n\"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\"\"\"\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_numbers = []\n    max_so_far = float('-inf')\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        max_numbers.append(max_so_far)\n    return max_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\nin the sequence.\n>>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n[1, 1, 1, 2, 2, 2, 2]\n\"\"\"\ndef rolling_min(numbers: List[int]) -> List[int]:\n    min_numbers = []\n    min_so_far = float('inf')\n    for number in numbers:\n        min_so_far = min(min_so_far, number)\n        min_numbers.append(min_so_far)\n    return min_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling sum found until given moment in the sequence.\n>>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n[1, 3, 6, 8, 11, 15, 17]\n\"\"\"\ndef rolling_sum(numbers: List[int]) -> List[int]:\n    sum_numbers = []\n    sum_so_far = 0\n    for number in numbers:\n        sum_so_far += number\n        sum_numbers.append(sum_so_far)\n    return sum_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling average found until given moment in the sequence.\n>>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 3.5]\n\"\"\"\ndef rolling_average(numbers: List[int]) -> List[float]:\n    sum_numbers = rolling_sum(numbers)\n    n = len(numbers)\n    return [sum_numbers[i]/n for i in range(n)]\n\n\n\"\"\" From a given list of integers, generate a list of rolling median found until given moment in the", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    max_numbers = []\n    max_so_far = float('-inf')\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        max_numbers.append(max_so_far)\n    return max_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\nin the sequence.\n>>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n[1, 1, 1, 2, 2, 2, 2]\n\"\"\"\ndef rolling_min(numbers: List[int]) -> List[int]:\n    min_numbers = []\n    min_so_far = float('inf')\n    for number in numbers:\n        min_so_far = min(min_so_far, number)\n        min_numbers.append(min_so_far)\n    return min_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling sum found until given moment in the sequence.\n>>> rolling_sum([1, 2, 3, 2, 3, 4, 2])\n[1, 3, 6, 8, 11, 15, 17]\n\"\"\"\ndef rolling_sum(numbers: List[int]) -> List[int]:\n    sum_numbers = []\n    sum_so_far = 0\n    for number in numbers:\n        sum_so_far += number\n        sum_numbers.append(sum_so_far)\n    return sum_numbers\n\n\n\"\"\" From a given list of integers, generate a list of rolling average found until given moment in the sequence.\n>>> rolling_average([1, 2, 3, 2, 3, 4, 2])\n[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 3.5]"}
{"ID": 81, "source": "HumanEval:HumanEval/81", "prompt": "\n\"\"\"It is the last week of the semester and the teacher has to give the grades\nto students. The teacher has been making her own algorithm for grading.\nThe only problem is, she has lost the code she used for grading.\nShe has given you a list of GPAs for some students and you have to write \na function that can output a list of letter grades using the following table:\n         GPA       |    Letter grade\n          4.0                A+\n        > 3.7                A \n        > 3.3                A- \n        > 3.0                B+\n        > 2.7                B \n        > 2.3                B-\n        > 2.0                C+\n        > 1.7                C\n        > 1.3                C-\n        > 1.0                D+ \n        > 0.7                D \n        > 0.0                D-\n          0.0                E\n\n\nExample:\ngrade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n\"\"\"\ndef numerical_letter_grade(grades):", "predict": "\n\"\"\"It is the last week of the semester and the teacher has to give the grades\nto students. The teacher has been making her own algorithm for grading.\nThe only problem is, she has lost the code she used for grading.\nShe has given you a list of GPAs for some students and you have to write \na function that can output a list of letter grades using the following table:\n         GPA       |    Letter grade\n          4.0                A+\n        > 3.7                A \n        > 3.3                A- \n        > 3.0                B+\n        > 2.7                B \n        > 2.3                B-\n        > 2.0                C+\n        > 1.7                C\n        > 1.3                C-\n        > 1.0                D+ \n        > 0.7                D \n        > 0.0                D-\n          0.0                E\n\n\nExample:\ngrade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n\"\"\"\ndef numerical_letter_grade(grades):\n    \"\"\"\n    This function takes a list of GPAs and returns a list of numerical letter grades.\n    \"\"\"\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.3:\n            letter_grades.append('B-')\n        elif grade >= 2.0:\n            letter_grades.append('C+')\n        elif grade >= 1.7:\n            letter_grades.append('C')\n        elif grade >= 1.3:\n            letter_grades.append('C-')\n        elif grade >= 1.0:\n            letter_grades.append('D+')\n        elif grade >= 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('D-')\n    return letter_grades\n\ndef grade_equation(grades):\n    \"\"\"\n    This function takes a list of GPAs and returns a list of letter grades using the grade equation.\n    \"\"\"\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.3:\n            letter_grades.append('B-')\n        elif grade >= 2.0:\n            letter_grades.append('C+')\n        elif grade >= 1.7:\n            letter_grades.append('C')\n        elif grade >= 1.3:\n            letter_grades.append('C-')\n        elif grade >= 1.0:\n            letter_grades.append('D+')", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "    This function takes a list of GPAs and returns a list of numerical letter grades.\n    \"\"\"\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.3:\n            letter_grades.append('B-')\n        elif grade >= 2.0:\n            letter_grades.append('C+')\n        elif grade >= 1.7:\n            letter_grades.append('C')\n        elif grade >= 1.3:\n            letter_grades.append('C-')\n        elif grade >= 1.0:\n            letter_grades.append('D+')\n        elif grade >= 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('D-')\n    return letter_grades\n\ndef grade_equation(grades):\n    \"\"\"\n    This function takes a list of GPAs and returns a list of letter grades using the grade equation.\n    \"\"\"\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.3:\n            letter_grades.append('B-')"}
{"ID": 92, "source": "HumanEval:HumanEval/92", "prompt": "\n\ndef any_int(x, y, z):", "predict": "\n\ndef any_int(x, y, z):\n    return any(isinstance(i, int) for i in [x, y, z])\n\ndef any_float(x, y, z):\n    return any(isinstance(i, float) for i in [x, y, z])\n\ndef any_str(x, y, z):\n    return any(isinstance(i, str) for i in [x, y, z])\n\ndef any_bool(x, y, z):\n    return any(isinstance(i, bool) for i in [x, y, z])\n\ndef any_list(x, y, z):\n    return any(isinstance(i, list) for i in [x, y, z])\n\ndef any_tuple(x, y, z):\n    return any(isinstance(i, tuple) for i in [x, y, z])\n\ndef any_dict(x, y, z):\n    return any(isinstance(i, dict) for i in [x, y, z])\n\ndef any_set(x, y, z):\n    return any(isinstance(i, set) for i in [x, y, z])\n\ndef any_none(x, y, z):\n    return any(i is None for i in [x, y, z])\n\ndef any_not_none(x, y, z):\n    return any(i is not None for i in [x, y, z])\n\ndef all_int(x, y, z):\n    return all(isinstance(i, int) for i in [x, y, z])\n\ndef all_float(x, y, z):\n    return all(isinstance(i, float) for i in [x, y, z])\n\ndef all_str(x, y, z):\n    return all(isinstance(i, str) for i in [x, y, z])\n\ndef all_bool(x, y, z):\n    return all(isinstance(i, bool) for i in [x, y, z])\n\ndef all_list(x, y, z):\n    return all(isinstance(i, list) for i in [x, y, z])\n\ndef all_tuple(x, y, z):\n    return all(isinstance(i, tuple) for i in [x, y, z])", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    return any(isinstance(i, int) for i in [x, y, z])\n\ndef any_float(x, y, z):\n    return any(isinstance(i, float) for i in [x, y, z])\n\ndef any_str(x, y, z):\n    return any(isinstance(i, str) for i in [x, y, z])\n\ndef any_bool(x, y, z):\n    return any(isinstance(i, bool) for i in [x, y, z])\n\ndef any_list(x, y, z):\n    return any(isinstance(i, list) for i in [x, y, z])\n\ndef any_tuple(x, y, z):\n    return any(isinstance(i, tuple) for i in [x, y, z])\n\ndef any_dict(x, y, z):\n    return any(isinstance(i, dict) for i in [x, y, z])\n\ndef any_set(x, y, z):\n    return any(isinstance(i, set) for i in [x, y, z])\n\ndef any_none(x, y, z):\n    return any(i is None for i in [x, y, z])\n\ndef any_not_none(x, y, z):\n    return any(i is not None for i in [x, y, z])\n\ndef all_int(x, y, z):\n    return all(isinstance(i, int) for i in [x, y, z])\n\ndef all_float(x, y, z):\n    return all(isinstance(i, float) for i in [x, y, z])\n\ndef all_str(x, y, z):\n    return all(isinstance(i, str) for i in [x, y, z])\n\ndef all_bool(x, y, z):\n    return all(isinstance(i, bool) for i in [x, y, z])\n\ndef all_list(x, y, z):\n    return all(isinstance(i, list) for i in [x, y, z])\n"}
{"ID": 119, "source": "HumanEval:HumanEval/119", "prompt": "\n\ndef match_parens(lst):", "predict": "\n\ndef match_parens(lst):\n    \"\"\"\n    Given a list of tokens, returns a list of tuples representing the matched\n    parentheses. Each tuple contains the indices of the opening and closing\n    parentheses. If there are no matched parentheses, an empty list is returned.\n    \"\"\"\n    stack = []\n    matches = []\n    for i, token in enumerate(lst):\n        if token == '(':\n            stack.append(i)\n        elif token == ')':\n            if stack:\n                matches.append((stack.pop(), i))\n            else:\n                return []\n    return matches\n\ndef find_matching_paren(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns the index of the matching\n    closing parenthesis. If there is no matching closing parenthesis, returns\n    None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                stack.pop()\n            else:\n                return j\n    return None\n\ndef find_matching_paren_index(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns the index of the matching\n    closing parenthesis. If there is no matching closing parenthesis, returns\n    None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                stack.pop()\n            else:\n                return j\n    return None\n\ndef find_matching_paren_indices(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns a tuple of the indices of\n    the matching opening and closing parentheses. If there is no matching\n    parentheses, returns None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                return (stack.pop(), j)\n            else:\n                return None\n    return None\n\ndef find_matching_paren_indices_reverse(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns a tuple of the indices of\n    the matching opening and closing parentheses. If there is no matching\n    parentheses, returns None.\n    \"\"\"\n    stack", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "    parentheses. If there are no matched parentheses, an empty list is returned.\n    \"\"\"\n    stack = []\n    matches = []\n    for i, token in enumerate(lst):\n        if token == '(':\n            stack.append(i)\n        elif token == ')':\n            if stack:\n                matches.append((stack.pop(), i))\n            else:\n                return []\n    return matches\n\ndef find_matching_paren(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns the index of the matching\n    closing parenthesis. If there is no matching closing parenthesis, returns\n    None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                stack.pop()\n            else:\n                return j\n    return None\n\ndef find_matching_paren_index(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns the index of the matching\n    closing parenthesis. If there is no matching closing parenthesis, returns\n    None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                stack.pop()\n            else:\n                return j\n    return None\n\ndef find_matching_paren_indices(lst, i):\n    \"\"\"\n    Given a list of tokens and an index i, returns a tuple of the indices of\n    the matching opening and closing parentheses. If there is no matching\n    parentheses, returns None.\n    \"\"\"\n    stack = []\n    for j, token in enumerate(lst[i+1:], i+1):\n        if token == '(':\n            stack.append(j)\n        elif token == ')':\n            if stack:\n                return (stack.pop(), j)\n            else:\n                return None\n    return None"}
{"ID": 132, "source": "HumanEval:HumanEval/132", "prompt": "\n\ndef is_nested(string):", "predict": "\n\ndef is_nested(string):\n    \"\"\"\n    Check if a string is nested or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_balanced(string):\n    \"\"\"\n    Check if a string is balanced or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid(string):\n    \"\"\"\n    Check if a string is valid or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_2(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_3(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_4(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_5(string):\n   ", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    \"\"\"\n    Check if a string is nested or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_balanced(string):\n    \"\"\"\n    Check if a string is balanced or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid(string):\n    \"\"\"\n    Check if a string is valid or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_2(string):\n    \"\"\"\n    Check if a string is valid parentheses or not.\n    \"\"\"\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef is_valid_parentheses_3(string):\n    \"\"\""}
{"ID": 134, "source": "HumanEval:HumanEval/134", "prompt": "\n\ndef check_if_last_char_is_a_letter(txt):", "predict": "\n\ndef check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Check if the last character of a string is a letter.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a letter, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1].isalpha()\n\ndef check_if_last_char_is_a_number(txt):\n    \"\"\"\n    Check if the last character of a string is a number.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a number, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1].isdigit()\n\ndef check_if_last_char_is_a_punctuation(txt):\n    \"\"\"\n    Check if the last character of a string is a punctuation mark.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a punctuation mark, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] in string.punctuation\n\ndef check_if_last_char_is_a_space(txt):\n    \"\"\"\n    Check if the last character of a string is a space.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a space, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] ==''\n\ndef check_if_last_char_is_a_symbol(txt):\n    \"\"\"\n    Check if the last character of a string is a symbol.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a symbol, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] in string.punctuation and not txt[-1] in string.ascii_letters and not txt[-1] in string.digits\n\ndef check_if_last_char_is_a_vowel(txt):\n    \"\"\"\n    Check if the last character of a string is a vowel.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a vowel, False otherwise.\n    :rtype: bool\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o',", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a punctuation mark, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] in string.punctuation\n\ndef check_if_last_char_is_a_space(txt):\n    \"\"\"\n    Check if the last character of a string is a space.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a space, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] ==''\n\ndef check_if_last_char_is_a_symbol(txt):\n    \"\"\"\n    Check if the last character of a string is a symbol.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a symbol, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return txt[-1] in string.punctuation and not txt[-1] in string.ascii_letters and not txt[-1] in string.digits\n\ndef check_if_last_char_is_a_vowel(txt):\n    \"\"\"\n    Check if the last character of a string is a vowel.\n\n    :param txt: The string to check.\n    :type txt: str\n    :return: True if the last character is a vowel, False otherwise.\n    :rtype: bool\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o',"}
{"ID": 157, "source": "HumanEval:HumanEval/157", "prompt": "\n\ndef right_angle_triangle(a, b, c):", "predict": "\n\ndef right_angle_triangle(a, b, c):\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_right_angle_triangle(a, b, c):\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_valid_triangle(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        return True\n    else:\n        return False\n\ndef is_equilateral(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n\ndef is_isosceles(a, b, c):\n    if a == b or b == c or c == a:\n        return True\n    else:\n        return False\n\ndef is_scalene(a, b, c):\n    if a!= b!= c!= a:\n        return True\n    else:\n        return False\n\ndef is_degenerate(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n\ndef is_right(a, b, c):\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_obtuse(a, b, c):\n    if a**2 + b**2 < c**2 or b**2 + c**2 < a**2 or c**2 + a**2 < b**2:\n        return True\n    else:\n        return False\n\ndef is_acute(a, b, c):\n    if a**2 + b**2 > c**2 or b**2 + c**2 > a**2 or c**2 + a**2 > b**2:\n        return True\n    else:\n        return False\n\ndef is_obtuse_angled(a, b, c):\n    if a**2 + b**2 < c**2 or b**2 + c**2 < a**2", "is_repeat": true, "repeat_type": "block_repetition", "repeat_code": "\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_right_angle_triangle(a, b, c):\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_valid_triangle(a, b, c):\n    if a + b > c and b + c > a and c + a > b:\n        return True\n    else:\n        return False\n\ndef is_equilateral(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n\ndef is_isosceles(a, b, c):\n    if a == b or b == c or c == a:\n        return True\n    else:\n        return False\n\ndef is_scalene(a, b, c):\n    if a!= b!= c!= a:\n        return True\n    else:\n        return False\n\ndef is_degenerate(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n\ndef is_right(a, b, c):\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or c**2 + a**2 == b**2:\n        return True\n    else:\n        return False\n\ndef is_obtuse(a, b, c):\n    if a**2 + b**2 < c**2 or b**2 + c**2 < a**2 or c**2 + a**2 < b**2:\n        return True\n    else:\n        return False\n\ndef is_acute(a, b, c):\n    if a**2 + b**2 > c**2 or b**2 + c**2 > a**2 or c**2 + a**2 > b**2:\n        return True\n    else:\n        return False\n"}
